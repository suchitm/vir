# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

mv_probit_lp_m_lq_z <- function(X_s, Y_s, mu_theta, msigma_theta, mu_psi, msigma_psi, mu_b0, vsigma2_b0, mu_B, msigma_B, logdet_msigma_psi, logdet_msigma_theta, N, S, M) {
    .Call(`_vir_mv_probit_lp_m_lq_z`, X_s, Y_s, mu_theta, msigma_theta, mu_psi, msigma_psi, mu_b0, vsigma2_b0, mu_B, msigma_B, logdet_msigma_psi, logdet_msigma_theta, N, S, M)
}

lp_indep_matrix_normal <- function(mu_prec, mu_logdet_prec, mu, msigma, P, M) {
    .Call(`_vir_lp_indep_matrix_normal`, mu_prec, mu_logdet_prec, mu, msigma, P, M)
}

#' Univariate normal linear regression with a Horseshoe prior using a Gibbs
#' sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @export
lm_hs_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.1, b_tau = 0.1) {
    .Call(`_vir_lm_hs_gibbs`, y, X, verbose, n_iter, a_tau, b_tau)
}

#' Univariate normal linear regression with a Horseshoe prior using the CAVI
#' algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_hs_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_hs_cavi`, y, X, n_iter, verbose, a_tau, b_tau, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
lm_hs_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, type = 0L, batch_size = 10L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_hs_svi`, y, X, verbose, n_iter, a_tau, b_tau, type, batch_size, const_rhot, omega, kappa)
}

#' Univariate normal linear regression with a LASSO (double-exponential) prior
#' using a Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
lm_lasso_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1) {
    .Call(`_vir_lm_lasso_gibbs`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda, b_lambda)
}

#' Univariate normal linear regression with a LASSO (double-exponential) prior
#' using the CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_lasso_cavi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, a_lambda2 = 0.1, b_lambda2 = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_lasso_cavi`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda2, b_lambda2, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
lm_lasso_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, a_lambda2 = 0.1, b_lambda2 = 0.1, type = 0L, batch_size = 10L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_lasso_svi`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda2, b_lambda2, type, batch_size, const_rhot, omega, kappa)
}

#' Univariate normal linear regression with a ridge (normal) prior using a
#' Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
lm_ridge_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.01, b_tau = 0.01, a_lambda = 0.01, b_lambda = 0.01) {
    .Call(`_vir_lm_ridge_gibbs`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda, b_lambda)
}

#' samples the mean
#' @export
lm_ridge_gibbs_b0 <- function(y_bar, tau, b0, N) {
    .Call(`_vir_lm_ridge_gibbs_b0`, y_bar, tau, b0, N)
}

#' function to update the coefficients in a linear regression
#' @param X N by P matrix of covariates
#' @export
lm_ridge_gibbs_b <- function(X, y, lambda, tau, b, P) {
    .Call(`_vir_lm_ridge_gibbs_b`, X, y, lambda, tau, b, P)
}

#' updates the precision parameter tau in a bayesian ridge regression
#' @export
lm_ridge_gibbs_tau <- function(ehat, b, lambda, tau, a_tau, b_tau, N, P) {
    .Call(`_vir_lm_ridge_gibbs_tau`, ehat, b, lambda, tau, a_tau, b_tau, N, P)
}

#' updates the prior precision parameter of b, lambda, in a bayesian ridge
#' regression
#' @export
lm_ridge_gibbs_lambda <- function(b, tau, lambda, a_lambda, b_lambda, P) {
    .Call(`_vir_lm_ridge_gibbs_lambda`, b, tau, lambda, a_lambda, b_lambda, P)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_ridge_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_ridge_cavi`, y, X, n_iter, verbose, a_tau, b_tau, a_lambda, b_lambda, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
lm_ridge_svi <- function(y, X, n_iter = 15000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1, type = 0L, batch_size = 42L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_ridge_svi`, y, X, n_iter, verbose, a_tau, b_tau, a_lambda, b_lambda, type, batch_size, const_rhot, omega, kappa)
}

mv_lm_uninf_gibbs_cpp <- function(Y, X, K = 2L, n_iter = 10000L, burn_in = 5000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1) {
    .Call(`_vir_mv_lm_uninf_gibbs_cpp`, Y, X, K, n_iter, burn_in, verbose, a_tau, b_tau)
}

#' Estimate the parameters in a multivariate linear model with the CAVI
#' algorithm.
#' @title Multivariate linear regression with a factor model - CAVI
#' @param Y matrix of responses
#' @param X matrix of predictors to control for
#' @param K number of factors in the factor model
#' @param n_iter number of iterations to run the Gibbs sampler
#' @param verbose True or False. Print status of the sampler.
#' @param a_tau Prior shape for the nugget term.
#' @param b_tau Prior rate for the nugget term.
#' @param rel_tol Relative tolerance for stopping
#' @param abs_tol Absolute tolerance for stopping; considered only after
#'   relative tolerance is met.
#' @export
mv_lm_uninf_cavi <- function(Y, X, K, n_iter, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, rel_tol = 0.0001, abs_tol = 0.1) {
    .Call(`_vir_mv_lm_uninf_cavi`, Y, X, K, n_iter, verbose, a_tau, b_tau, rel_tol, abs_tol)
}

mv_probit_uninf_gibbs_cpp <- function(Y, X, K = 2L, n_iter = 10000L, burn_in = 5000L, verbose = TRUE) {
    .Call(`_vir_mv_probit_uninf_gibbs_cpp`, Y, X, K, n_iter, burn_in, verbose)
}

mv_probit_uninf_cavi_cpp <- function(Y, X, K, n_iter, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, rel_tol = 0.00001) {
    .Call(`_vir_mv_probit_uninf_cavi_cpp`, Y, X, K, n_iter, verbose, a_tau, b_tau, rel_tol)
}

mv_probit_uninf_svi_cpp <- function(Y, X, K, n_iter, verbose = TRUE, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_mv_probit_uninf_svi_cpp`, Y, X, K, n_iter, verbose, batch_size, omega, kappa, const_rhot)
}

probit_gibbs_z <- function(y, eta, N, z) {
    .Call(`_vir_probit_gibbs_z`, y, eta, N, z)
}

probit_gibbs_b0 <- function(ehat, N, b0) {
    .Call(`_vir_probit_gibbs_b0`, ehat, N, b0)
}

probit_gibbs_b <- function(X, ehat, prior_mat, P, b) {
    .Call(`_vir_probit_gibbs_b`, X, ehat, prior_mat, P, b)
}

probit_log_lik <- function(y, X, b0, b, N) {
    .Call(`_vir_probit_log_lik`, y, X, b0, b, N)
}

probit_vi_z <- function(X_s, param_b0, param_b, S, param_z) {
    .Call(`_vir_probit_vi_z`, X_s, param_b0, param_b, S, param_z)
}

probit_vi_b0 <- function(X_s, param_z, param_b, N, S, param_b0) {
    .Call(`_vir_probit_vi_b0`, X_s, param_z, param_b, N, S, param_b0)
}

probit_vi_b <- function(X_s, param_z, param_b0, mu_prior_mat, N, S, P, type, cavi, param_b) {
    .Call(`_vir_probit_vi_b`, X_s, param_z, param_b0, mu_prior_mat, N, S, P, type, cavi, param_b)
}

#' Univariate probit linear regression with a Horseshoe prior using a
#' Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#'   (shrinkage) term.
#' @export
probit_hs_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L) {
    .Call(`_vir_probit_hs_gibbs`, y, X, verbose, n_iter)
}

#' Univariate probit linear regression with a Horseshoe prior using the CAVI
#' algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True or False. Do you want to print messages along the way?
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_hs_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_hs_cavi`, y, X, n_iter, verbose, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True or False. Do you want to print messages along the way?
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
probit_hs_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_hs_svi`, y, X, verbose, n_iter, type, batch_size, omega, kappa, const_rhot)
}

#' Univariate probit linear regression with a LASSO prior using a
#' Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
probit_lasso_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_lambda2 = 0.1, b_lambda2 = 0.1) {
    .Call(`_vir_probit_lasso_gibbs`, y, X, verbose, n_iter, a_lambda2, b_lambda2)
}

#' Univariate probit linear regression with a LASSO (double-exponential) prior
#' using the CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_lasso_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_lambda2 = 0.1, b_lambda2 = 0.1, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_lasso_cavi`, y, X, n_iter, verbose, a_lambda2, b_lambda2, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
probit_lasso_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_lambda2 = 0.1, b_lambda2 = 0.1, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_lasso_svi`, y, X, verbose, n_iter, a_lambda2, b_lambda2, type, batch_size, omega, kappa, const_rhot)
}

#' Univariate probit linear regression with a ridge (normal) prior using a
#' Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
probit_ridge_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_lambda = 0.01, b_lambda = 0.01) {
    .Call(`_vir_probit_ridge_gibbs`, y, X, verbose, n_iter, a_lambda, b_lambda)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_ridge_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_lambda = 0.1, b_lambda = 0.1, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_ridge_cavi`, y, X, n_iter, verbose, a_lambda, b_lambda, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True or False. Do you want to print messages along the way?
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   (0.5, 1)}
#' @export
probit_ridge_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_lambda = 0.1, b_lambda = 0.1, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_ridge_svi`, y, X, verbose, n_iter, a_lambda, b_lambda, type, batch_size, omega, kappa, const_rhot)
}

