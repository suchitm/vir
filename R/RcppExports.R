# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' samples the mean
#' @export
lm_hs_gibbs_b0 <- function(y_bar, tau, N, b0) {
    .Call(`_vir_lm_hs_gibbs_b0`, y_bar, tau, N, b0)
}

#' function to update the coefficients in a linear regression
#' @param X N by P matrix of covariates
#' @export
lm_hs_gibbs_b <- function(X, y_tilde, tau, lambda, gammas, P, b) {
    .Call(`_vir_lm_hs_gibbs_b`, X, y_tilde, tau, lambda, gammas, P, b)
}

#' updates the precision parameter tau in a bayesian hs regression
#' @export
lm_hs_gibbs_tau <- function(ehat, b, lambda, gammas, a_tau, b_tau, N, P, tau) {
    .Call(`_vir_lm_hs_gibbs_tau`, ehat, b, lambda, gammas, a_tau, b_tau, N, P, tau)
}

#' @export
lm_hs_gibbs_lambda <- function(b, tau, gammas, xi, P, lambda) {
    .Call(`_vir_lm_hs_gibbs_lambda`, b, tau, gammas, xi, P, lambda)
}

#' update the latent variables for the double exponential prior
lm_hs_gibbs_gammas <- function(tau, lambda, nus, b, P, gammas) {
    .Call(`_vir_lm_hs_gibbs_gammas`, tau, lambda, nus, b, P, gammas)
}

lm_hs_gibbs_xi <- function(lambda, xi) {
    .Call(`_vir_lm_hs_gibbs_xi`, lambda, xi)
}

lm_hs_gibbs_nus <- function(gammas, P, nus) {
    .Call(`_vir_lm_hs_gibbs_nus`, gammas, P, nus)
}

#' Univariate normal linear regression with a Horseshoe prior using a Gibbs
#' sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @export
lm_hs_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.1, b_tau = 0.1) {
    .Call(`_vir_lm_hs_gibbs`, y, X, verbose, n_iter, a_tau, b_tau)
}

lm_hs_vi_elbo <- function(X_s, y_s, param_b0, param_b, param_tau, param_lambda, param_xi, param_gamma, param_nu, a_tau, b_tau, N, S, P) {
    .Call(`_vir_lm_hs_vi_elbo`, X_s, y_s, param_b0, param_b, param_tau, param_lambda, param_xi, param_gamma, param_nu, a_tau, b_tau, N, S, P)
}

#' Univariate normal linear regression with a Horseshoe prior using the CAVI
#' algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_hs_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_hs_cavi`, y, X, n_iter, verbose, a_tau, b_tau, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
lm_hs_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, type = 0L, batch_size = 10L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_hs_svi`, y, X, verbose, n_iter, a_tau, b_tau, type, batch_size, const_rhot, omega, kappa)
}

#' samples the mean
#' @export
lm_lasso_gibbs_b0 <- function(y_bar, tau, N, b0) {
    .Call(`_vir_lm_lasso_gibbs_b0`, y_bar, tau, N, b0)
}

#' function to update the coefficients in a linear regression
#' @param X N by P matrix of covariates
#' @export
lm_lasso_gibbs_b <- function(X, y_tilde, gammas, tau, P, b) {
    .Call(`_vir_lm_lasso_gibbs_b`, X, y_tilde, gammas, tau, P, b)
}

#' updates the precision parameter tau in a bayesian lasso regression
#' @export
lm_lasso_gibbs_tau <- function(ehat, b, gammas, a_tau, b_tau, N, P, tau) {
    .Call(`_vir_lm_lasso_gibbs_tau`, ehat, b, gammas, a_tau, b_tau, N, P, tau)
}

#' update the latent variables for the double exponential prior
lm_lasso_gibbs_gammas <- function(tau, lambda2, b, P, gammas) {
    .Call(`_vir_lm_lasso_gibbs_gammas`, tau, lambda2, b, P, gammas)
}

#' updates the prior precision parameter of b, lambda, in a bayesian lasso
#' regression
#' @export
lm_lasso_gibbs_lambda2 <- function(gammas, a_lambda, b_lambda, P, lambda2) {
    .Call(`_vir_lm_lasso_gibbs_lambda2`, gammas, a_lambda, b_lambda, P, lambda2)
}

#' Univariate normal linear regression with a LASSO (double-exponential) prior
#' using a Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
lm_lasso_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1) {
    .Call(`_vir_lm_lasso_gibbs`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda, b_lambda)
}

#' Univariate normal linear regression with a LASSO (double-exponential) prior
#' using the CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_lasso_cavi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, a_lambda2 = 0.1, b_lambda2 = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_lasso_cavi`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda2, b_lambda2, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
lm_lasso_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_tau = 0.1, b_tau = 0.1, a_lambda2 = 0.1, b_lambda2 = 0.1, type = 0L, batch_size = 10L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_lasso_svi`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda2, b_lambda2, type, batch_size, const_rhot, omega, kappa)
}

#' Univariate normal linear regression with a ridge (normal) prior using a
#' Gibbs sampler.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @export
lm_ridge_gibbs <- function(y, X, verbose = TRUE, n_iter = 10000L, a_tau = 0.01, b_tau = 0.01, a_lambda = 0.01, b_lambda = 0.01) {
    .Call(`_vir_lm_ridge_gibbs`, y, X, verbose, n_iter, a_tau, b_tau, a_lambda, b_lambda)
}

#' samples the mean
#' @export
lm_ridge_gibbs_b0 <- function(y_bar, tau, b0, N) {
    .Call(`_vir_lm_ridge_gibbs_b0`, y_bar, tau, b0, N)
}

#' function to update the coefficients in a linear regression
#' @param X N by P matrix of covariates
#' @export
lm_ridge_gibbs_b <- function(X, y, lambda, tau, b, P) {
    .Call(`_vir_lm_ridge_gibbs_b`, X, y, lambda, tau, b, P)
}

#' updates the precision parameter tau in a bayesian ridge regression
#' @export
lm_ridge_gibbs_tau <- function(ehat, b, lambda, tau, a_tau, b_tau, N, P) {
    .Call(`_vir_lm_ridge_gibbs_tau`, ehat, b, lambda, tau, a_tau, b_tau, N, P)
}

#' updates the prior precision parameter of b, lambda, in a bayesian ridge
#' regression
#' @export
lm_ridge_gibbs_lambda <- function(b, tau, lambda, a_lambda, b_lambda, P) {
    .Call(`_vir_lm_ridge_gibbs_lambda`, b, tau, lambda, a_lambda, b_lambda, P)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
lm_ridge_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1, rel_tol = 0.0001, type = 0L) {
    .Call(`_vir_lm_ridge_cavi`, y, X, n_iter, verbose, a_tau, b_tau, a_lambda, b_lambda, rel_tol, type)
}

#' Univariate normal linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_tau Prior shape parameter for the likelihood precision.
#' @param b_tau Prior rate parameter for the likelihood precision.
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
lm_ridge_svi <- function(y, X, n_iter = 15000L, verbose = TRUE, a_tau = 0.1, b_tau = 0.1, a_lambda = 0.1, b_lambda = 0.1, type = 0L, batch_size = 42L, const_rhot = 0.01, omega = 15.0, kappa = 0.6) {
    .Call(`_vir_lm_ridge_svi`, y, X, n_iter, verbose, a_tau, b_tau, a_lambda, b_lambda, type, batch_size, const_rhot, omega, kappa)
}

mv_probit_gibbs_Z <- function(Y, Eta, tau, N, M, Z) {
    .Call(`_vir_mv_probit_gibbs_Z`, Y, Eta, tau, N, M, Z)
}

mvlm_uninf_gibbs_b0 <- function(E_hat, tau, N, M, b0) {
    .Call(`_vir_mvlm_uninf_gibbs_b0`, E_hat, tau, N, M, b0)
}

mvlm_uninf_gibbs_B <- function(E_hat, X, tau, M, P, b) {
    .Call(`_vir_mvlm_uninf_gibbs_B`, E_hat, X, tau, M, P, b)
}

mvlm_uninf_gibbs_mtheta <- function(E_hat, mphi, mgamma, tau, lambda, M, K, mtheta) {
    .Call(`_vir_mvlm_uninf_gibbs_mtheta`, E_hat, mphi, mgamma, tau, lambda, M, K, mtheta)
}

mvlm_uninf_gibbs_mphi <- function(E_hat, mtheta, tau, N, K, mphi) {
    .Call(`_vir_mvlm_uninf_gibbs_mphi`, E_hat, mtheta, tau, N, K, mphi)
}

mvlm_uninf_gibbs_tau <- function(E_hat, N, M, a_tau, b_tau, tau) {
    .Call(`_vir_mvlm_uninf_gibbs_tau`, E_hat, N, M, a_tau, b_tau, tau)
}

mvlm_uninf_gibbs_mgamma <- function(mtheta, lambda, M, K, nu, mgamma) {
    .Call(`_vir_mvlm_uninf_gibbs_mgamma`, mtheta, lambda, M, K, nu, mgamma)
}

mvlm_uninf_gibbs_xi <- function(mtheta, mgamma, lambda, M, K, a1, a2, xi) {
    .Call(`_vir_mvlm_uninf_gibbs_xi`, mtheta, mgamma, lambda, M, K, a1, a2, xi)
}

mv_probit_vi_z <- function(Eta, param_tau, S, M, param_z) {
    .Call(`_vir_mv_probit_vi_z`, Eta, param_tau, S, M, param_z)
}

mvlm_vi_phi <- function(E_hat, param_theta, param_tau, S, M, K, param_phi) {
    .Call(`_vir_mvlm_vi_phi`, E_hat, param_theta, param_tau, S, M, K, param_phi)
}

mvlm_vi_theta <- function(E_hat, param_phi, param_tau, param_gamma, mu_lambda, N, M, S, K, param_theta) {
    .Call(`_vir_mvlm_vi_theta`, E_hat, param_phi, param_tau, param_gamma, mu_lambda, N, M, S, K, param_theta)
}

mvlm_vi_b0 <- function(E_hat, param_tau, N, M, S, param_b0) {
    .Call(`_vir_mvlm_vi_b0`, E_hat, param_tau, N, M, S, param_b0)
}

mvlm_vi_b <- function(E_hat, X, param_tau, N, M, P, S, param_b) {
    .Call(`_vir_mvlm_vi_b`, E_hat, X, param_tau, N, M, P, S, param_b)
}

mvlm_vi_tau <- function(E_hat, X, param_b0, param_b, param_phi, param_theta, N, M, P, S, K, a_tau, b_tau, param_tau) {
    .Call(`_vir_mvlm_vi_tau`, E_hat, X, param_b0, param_b, param_phi, param_theta, N, M, P, S, K, a_tau, b_tau, param_tau)
}

mvlm_vi_gamma <- function(param_theta, mu_lambda, M, K, nu, param_gamma) {
    .Call(`_vir_mvlm_vi_gamma`, param_theta, mu_lambda, M, K, nu, param_gamma)
}

mvlm_vi_xi <- function(param_gamma, param_theta, M, K, mu_lambda, a1, a2, param_xi, svb = FALSE) {
    .Call(`_vir_mvlm_vi_xi`, param_gamma, param_theta, M, K, mu_lambda, a1, a2, param_xi, svb)
}

mv_probit_vi_z_psi <- function(Y_s, E_hat, param_theta, S, M, K, param_psi, param_z) {
    .Call(`_vir_mv_probit_vi_z_psi`, Y_s, E_hat, param_theta, S, M, K, param_psi, param_z)
}

probit_gibbs_z <- function(y, eta, N, z) {
    .Call(`_vir_probit_gibbs_z`, y, eta, N, z)
}

probit_gibbs_b0 <- function(ehat, N, b0) {
    .Call(`_vir_probit_gibbs_b0`, ehat, N, b0)
}

probit_gibbs_b <- function(X, ehat, prior_mat, P, b) {
    .Call(`_vir_probit_gibbs_b`, X, ehat, prior_mat, P, b)
}

probit_log_lik <- function(y, X, b0, b, N) {
    .Call(`_vir_probit_log_lik`, y, X, b0, b, N)
}

probit_vi_z <- function(X_s, param_b0, param_b, S, param_z) {
    .Call(`_vir_probit_vi_z`, X_s, param_b0, param_b, S, param_z)
}

probit_vi_b0 <- function(X_s, param_z, param_b, N, S, param_b0) {
    .Call(`_vir_probit_vi_b0`, X_s, param_z, param_b, N, S, param_b0)
}

probit_vi_b <- function(X_s, param_z, param_b0, mu_prior_mat, N, S, P, type, cavi, param_b) {
    .Call(`_vir_probit_vi_b`, X_s, param_z, param_b0, mu_prior_mat, N, S, P, type, cavi, param_b)
}

probit_hs_elbo <- function(X_s, y_s, param_z, param_b0, param_b, param_lambda, param_xi, param_gamma, param_nu, N, S, P) {
    .Call(`_vir_probit_hs_elbo`, X_s, y_s, param_z, param_b0, param_b, param_lambda, param_xi, param_gamma, param_nu, N, S, P)
}

#' Univariate probit linear regression with a Horseshoe prior using the CAVI
#' algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_hs_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_hs_cavi`, y, X, n_iter, verbose, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
probit_hs_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_hs_svi`, y, X, verbose, n_iter, type, batch_size, omega, kappa, const_rhot)
}

probit_lasso_vi_lambda2 <- function(param_gamma, P, a_lambda2, b_lambda2, param_lambda2) {
    .Call(`_vir_probit_lasso_vi_lambda2`, param_gamma, P, a_lambda2, b_lambda2, param_lambda2)
}

probit_lasso_vi_gamma <- function(param_b, param_lambda2, P, param_gamma) {
    .Call(`_vir_probit_lasso_vi_gamma`, param_b, param_lambda2, P, param_gamma)
}

probit_lasso_elbo <- function(X_s, y_s, param_z, param_b0, param_b, param_lambda2, param_gamma, a_lambda2, b_lambda2, N, S, P) {
    .Call(`_vir_probit_lasso_elbo`, X_s, y_s, param_z, param_b0, param_b, param_lambda2, param_gamma, a_lambda2, b_lambda2, N, S, P)
}

#' Univariate probit linear regression with a LASSO (double-exponential) prior
#' using the CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_lasso_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_lambda2 = 0.1, b_lambda2 = 0.1, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_lasso_cavi`, y, X, n_iter, verbose, a_lambda2, b_lambda2, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_lambda2 Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda2 Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
probit_lasso_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_lambda2 = 0.1, b_lambda2 = 0.1, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_lasso_svi`, y, X, verbose, n_iter, a_lambda2, b_lambda2, type, batch_size, omega, kappa, const_rhot)
}

probit_ridge_vi_lambda <- function(param_b, P, a_lambda, b_lambda, param_lambda) {
    .Call(`_vir_probit_ridge_vi_lambda`, param_b, P, a_lambda, b_lambda, param_lambda)
}

probit_ridge_elbo <- function(X_s, y_s, param_z, param_b0, param_b, param_lambda, a_lambda, b_lambda, N, S, P) {
    .Call(`_vir_probit_ridge_elbo`, X_s, y_s, param_z, param_b0, param_b, param_lambda, a_lambda, b_lambda, N, S, P)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' CAVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Max number of iterations to run the algorithm for (default =
#'   1000). A convergence warning is issues if the algorithm runs for the max
#'   number of iterations.
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param rel_tol Relative tolerance used for convergence. Convergence is
#'   assesed using the evidence lower bound (ELBO) changes relative to five
#'   iterations prior.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @export
probit_ridge_cavi <- function(y, X, n_iter = 1000L, verbose = TRUE, a_lambda = 0.1, b_lambda = 0.1, tol = 0.0001, type = 0L) {
    .Call(`_vir_probit_ridge_cavi`, y, X, n_iter, verbose, a_lambda, b_lambda, tol, type)
}

#' Univariate probit linear regression with a ridge (normal) prior using the
#' SVI algorithm.
#' @param y Vector or responses (N by 1)
#' @param X Matrix of predictors (N by P)
#' @param n_iter Number of iterations to run the algorithm for (default =
#'   5000).
#' @param verbose True of False. Do you want to print messages along the way?
#' @param a_lambda Prior shape parameter for the coefficient precision
#'   (shrinkage) term.
#' @param b_lambda Prior rate parameter for the coefficient precision
#'   (shrinkage) term.
#' @param type Correlation structure of the regression coefficients. Use 0 for
#'   full correlation and 1 for independece assumption.
#' @param batch_size Size of the subsamples used to update the parameters.
#' @param cost_rhot Used to set a constant step size in the gradient descent
#'   algorithm. If this parameter is greater than zero, it overrides the step
#'   size iterations calculated using kappa and omega.
#' @param omega Delay for the stepsize (\eqn{\omega}) for the gradient step.
#'   Interacts with \eqn{\kappa} via the formula \eqn{\rho_{t} = (t +
#'   \omega)^{-\kappa}}. This parameter has to be greater than or equal to zero.
#' @param kappa Forgetting rate for the step size iterations; \eqn{\kappa \in
#'   \{0.5, 1\}}
#' @export
probit_ridge_svi <- function(y, X, verbose = TRUE, n_iter = 1000L, a_lambda = 0.1, b_lambda = 0.1, type = 0L, batch_size = 10L, omega = 15.0, kappa = 0.6, const_rhot = 0.01) {
    .Call(`_vir_probit_ridge_svi`, y, X, verbose, n_iter, a_lambda, b_lambda, type, batch_size, omega, kappa, const_rhot)
}

